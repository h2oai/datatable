// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_JAY_JAY_H_
#define FLATBUFFERS_GENERATED_JAY_JAY_H_

#include "lib/flatbuffers/flatbuffers.h"

namespace jay {

struct StatsBool;

struct StatsInt8;

struct StatsInt16;

struct StatsInt32;

struct StatsInt64;

struct StatsFloat32;

struct StatsFloat64;

struct Frame;

struct Column;

struct Buffer;

enum Type {
  Type_Bool8 = 0,
  Type_Int8 = 1,
  Type_Int16 = 2,
  Type_Int32 = 3,
  Type_Int64 = 4,
  Type_Float32 = 5,
  Type_Float64 = 6,
  Type_Str32 = 7,
  Type_Str64 = 8,
  Type_MIN = Type_Bool8,
  Type_MAX = Type_Str64
};

inline const Type (&EnumValuesType())[9] {
  static const Type values[] = {
    Type_Bool8,
    Type_Int8,
    Type_Int16,
    Type_Int32,
    Type_Int64,
    Type_Float32,
    Type_Float64,
    Type_Str32,
    Type_Str64
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[] = {
    "Bool8",
    "Int8",
    "Int16",
    "Int32",
    "Int64",
    "Float32",
    "Float64",
    "Str32",
    "Str64",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

enum Stats {
  Stats_NONE = 0,
  Stats_Bool = 1,
  Stats_Int8 = 2,
  Stats_Int16 = 3,
  Stats_Int32 = 4,
  Stats_Int64 = 5,
  Stats_Float32 = 6,
  Stats_Float64 = 7,
  Stats_MIN = Stats_NONE,
  Stats_MAX = Stats_Float64
};

inline const Stats (&EnumValuesStats())[8] {
  static const Stats values[] = {
    Stats_NONE,
    Stats_Bool,
    Stats_Int8,
    Stats_Int16,
    Stats_Int32,
    Stats_Int64,
    Stats_Float32,
    Stats_Float64
  };
  return values;
}

inline const char * const *EnumNamesStats() {
  static const char * const names[] = {
    "NONE",
    "Bool",
    "Int8",
    "Int16",
    "Int32",
    "Int64",
    "Float32",
    "Float64",
    nullptr
  };
  return names;
}

inline const char *EnumNameStats(Stats e) {
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStats()[index];
}

bool VerifyStats(flatbuffers::Verifier &verifier, const void *obj, Stats type);
bool VerifyStatsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) StatsBool FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t min_;
  int8_t max_;

 public:
  StatsBool() {
    memset(this, 0, sizeof(StatsBool));
  }
  StatsBool(int8_t _min, int8_t _max)
      : min_(flatbuffers::EndianScalar(_min)),
        max_(flatbuffers::EndianScalar(_max)) {
  }
  int8_t min() const {
    return flatbuffers::EndianScalar(min_);
  }
  int8_t max() const {
    return flatbuffers::EndianScalar(max_);
  }
};
FLATBUFFERS_STRUCT_END(StatsBool, 2);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) StatsInt8 FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t min_;
  int8_t max_;

 public:
  StatsInt8() {
    memset(this, 0, sizeof(StatsInt8));
  }
  StatsInt8(int8_t _min, int8_t _max)
      : min_(flatbuffers::EndianScalar(_min)),
        max_(flatbuffers::EndianScalar(_max)) {
  }
  int8_t min() const {
    return flatbuffers::EndianScalar(min_);
  }
  int8_t max() const {
    return flatbuffers::EndianScalar(max_);
  }
};
FLATBUFFERS_STRUCT_END(StatsInt8, 2);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) StatsInt16 FLATBUFFERS_FINAL_CLASS {
 private:
  int16_t min_;
  int16_t max_;

 public:
  StatsInt16() {
    memset(this, 0, sizeof(StatsInt16));
  }
  StatsInt16(int16_t _min, int16_t _max)
      : min_(flatbuffers::EndianScalar(_min)),
        max_(flatbuffers::EndianScalar(_max)) {
  }
  int16_t min() const {
    return flatbuffers::EndianScalar(min_);
  }
  int16_t max() const {
    return flatbuffers::EndianScalar(max_);
  }
};
FLATBUFFERS_STRUCT_END(StatsInt16, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) StatsInt32 FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t min_;
  int32_t max_;

 public:
  StatsInt32() {
    memset(this, 0, sizeof(StatsInt32));
  }
  StatsInt32(int32_t _min, int32_t _max)
      : min_(flatbuffers::EndianScalar(_min)),
        max_(flatbuffers::EndianScalar(_max)) {
  }
  int32_t min() const {
    return flatbuffers::EndianScalar(min_);
  }
  int32_t max() const {
    return flatbuffers::EndianScalar(max_);
  }
};
FLATBUFFERS_STRUCT_END(StatsInt32, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) StatsInt64 FLATBUFFERS_FINAL_CLASS {
 private:
  int64_t min_;
  int64_t max_;

 public:
  StatsInt64() {
    memset(this, 0, sizeof(StatsInt64));
  }
  StatsInt64(int64_t _min, int64_t _max)
      : min_(flatbuffers::EndianScalar(_min)),
        max_(flatbuffers::EndianScalar(_max)) {
  }
  int64_t min() const {
    return flatbuffers::EndianScalar(min_);
  }
  int64_t max() const {
    return flatbuffers::EndianScalar(max_);
  }
};
FLATBUFFERS_STRUCT_END(StatsInt64, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) StatsFloat32 FLATBUFFERS_FINAL_CLASS {
 private:
  float min_;
  float max_;

 public:
  StatsFloat32() {
    memset(this, 0, sizeof(StatsFloat32));
  }
  StatsFloat32(float _min, float _max)
      : min_(flatbuffers::EndianScalar(_min)),
        max_(flatbuffers::EndianScalar(_max)) {
  }
  float min() const {
    return flatbuffers::EndianScalar(min_);
  }
  float max() const {
    return flatbuffers::EndianScalar(max_);
  }
};
FLATBUFFERS_STRUCT_END(StatsFloat32, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) StatsFloat64 FLATBUFFERS_FINAL_CLASS {
 private:
  double min_;
  double max_;

 public:
  StatsFloat64() {
    memset(this, 0, sizeof(StatsFloat64));
  }
  StatsFloat64(double _min, double _max)
      : min_(flatbuffers::EndianScalar(_min)),
        max_(flatbuffers::EndianScalar(_max)) {
  }
  double min() const {
    return flatbuffers::EndianScalar(min_);
  }
  double max() const {
    return flatbuffers::EndianScalar(max_);
  }
};
FLATBUFFERS_STRUCT_END(StatsFloat64, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Buffer FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t offset_;
  uint64_t length_;

 public:
  Buffer() {
    memset(this, 0, sizeof(Buffer));
  }
  Buffer(uint64_t _offset, uint64_t _length)
      : offset_(flatbuffers::EndianScalar(_offset)),
        length_(flatbuffers::EndianScalar(_length)) {
  }
  uint64_t offset() const {
    return flatbuffers::EndianScalar(offset_);
  }
  uint64_t length() const {
    return flatbuffers::EndianScalar(length_);
  }
};
FLATBUFFERS_STRUCT_END(Buffer, 16);

struct Frame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NROWS = 4,
    VT_NCOLS = 6,
    VT_NKEYS = 8,
    VT_COLUMNS = 10
  };
  uint64_t nrows() const {
    return GetField<uint64_t>(VT_NROWS, 0);
  }
  uint64_t ncols() const {
    return GetField<uint64_t>(VT_NCOLS, 0);
  }
  int32_t nkeys() const {
    return GetField<int32_t>(VT_NKEYS, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Column>> *columns() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Column>> *>(VT_COLUMNS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_NROWS) &&
           VerifyField<uint64_t>(verifier, VT_NCOLS) &&
           VerifyField<int32_t>(verifier, VT_NKEYS) &&
           VerifyOffset(verifier, VT_COLUMNS) &&
           verifier.Verify(columns()) &&
           verifier.VerifyVectorOfTables(columns()) &&
           verifier.EndTable();
  }
};

struct FrameBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  int : 32;
  void add_nrows(uint64_t nrows) {
    fbb_.AddElement<uint64_t>(Frame::VT_NROWS, nrows, 0);
  }
  void add_ncols(uint64_t ncols) {
    fbb_.AddElement<uint64_t>(Frame::VT_NCOLS, ncols, 0);
  }
  void add_nkeys(int32_t nkeys) {
    fbb_.AddElement<int32_t>(Frame::VT_NKEYS, nkeys, 0);
  }
  void add_columns(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Column>>> columns) {
    fbb_.AddOffset(Frame::VT_COLUMNS, columns);
  }
  explicit FrameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FrameBuilder &operator=(const FrameBuilder &);
  flatbuffers::Offset<Frame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Frame>(end);
    return o;
  }
};

inline flatbuffers::Offset<Frame> CreateFrame(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t nrows = 0,
    uint64_t ncols = 0,
    int32_t nkeys = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Column>>> columns = 0) {
  FrameBuilder builder_(_fbb);
  builder_.add_ncols(ncols);
  builder_.add_nrows(nrows);
  builder_.add_columns(columns);
  builder_.add_nkeys(nkeys);
  return builder_.Finish();
}

inline flatbuffers::Offset<Frame> CreateFrameDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t nrows = 0,
    uint64_t ncols = 0,
    int32_t nkeys = 0,
    const std::vector<flatbuffers::Offset<Column>> *columns = nullptr) {
  return jay::CreateFrame(
      _fbb,
      nrows,
      ncols,
      nkeys,
      columns ? _fbb.CreateVector<flatbuffers::Offset<Column>>(*columns) : 0);
}

struct Column FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_DATA = 6,
    VT_STRDATA = 8,
    VT_NAME = 10,
    VT_NULLCOUNT = 12,
    VT_STATS_TYPE = 14,
    VT_STATS = 16
  };
  Type type() const {
    return static_cast<Type>(GetField<uint8_t>(VT_TYPE, 0));
  }
  const Buffer *data() const {
    return GetStruct<const Buffer *>(VT_DATA);
  }
  const Buffer *strdata() const {
    return GetStruct<const Buffer *>(VT_STRDATA);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint64_t nullcount() const {
    return GetField<uint64_t>(VT_NULLCOUNT, 0);
  }
  Stats stats_type() const {
    return static_cast<Stats>(GetField<uint8_t>(VT_STATS_TYPE, 0));
  }
  const void *stats() const {
    return GetPointer<const void *>(VT_STATS);
  }
  template<typename T> const T *stats_as() const;
  const StatsBool *stats_as_Bool() const {
    return stats_type() == Stats_Bool ? static_cast<const StatsBool *>(stats()) : nullptr;
  }
  const StatsInt8 *stats_as_Int8() const {
    return stats_type() == Stats_Int8 ? static_cast<const StatsInt8 *>(stats()) : nullptr;
  }
  const StatsInt16 *stats_as_Int16() const {
    return stats_type() == Stats_Int16 ? static_cast<const StatsInt16 *>(stats()) : nullptr;
  }
  const StatsInt32 *stats_as_Int32() const {
    return stats_type() == Stats_Int32 ? static_cast<const StatsInt32 *>(stats()) : nullptr;
  }
  const StatsInt64 *stats_as_Int64() const {
    return stats_type() == Stats_Int64 ? static_cast<const StatsInt64 *>(stats()) : nullptr;
  }
  const StatsFloat32 *stats_as_Float32() const {
    return stats_type() == Stats_Float32 ? static_cast<const StatsFloat32 *>(stats()) : nullptr;
  }
  const StatsFloat64 *stats_as_Float64() const {
    return stats_type() == Stats_Float64 ? static_cast<const StatsFloat64 *>(stats()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyField<Buffer>(verifier, VT_DATA) &&
           VerifyField<Buffer>(verifier, VT_STRDATA) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<uint64_t>(verifier, VT_NULLCOUNT) &&
           VerifyField<uint8_t>(verifier, VT_STATS_TYPE) &&
           VerifyOffset(verifier, VT_STATS) &&
           VerifyStats(verifier, stats(), stats_type()) &&
           verifier.EndTable();
  }
};

struct ColumnBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  int : 32;
  void add_type(Type type) {
    fbb_.AddElement<uint8_t>(Column::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_data(const Buffer *data) {
    fbb_.AddStruct(Column::VT_DATA, data);
  }
  void add_strdata(const Buffer *strdata) {
    fbb_.AddStruct(Column::VT_STRDATA, strdata);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Column::VT_NAME, name);
  }
  void add_nullcount(uint64_t nullcount) {
    fbb_.AddElement<uint64_t>(Column::VT_NULLCOUNT, nullcount, 0);
  }
  void add_stats_type(Stats stats_type) {
    fbb_.AddElement<uint8_t>(Column::VT_STATS_TYPE, static_cast<uint8_t>(stats_type), 0);
  }
  void add_stats(flatbuffers::Offset<void> stats) {
    fbb_.AddOffset(Column::VT_STATS, stats);
  }
  explicit ColumnBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ColumnBuilder &operator=(const ColumnBuilder &);
  flatbuffers::Offset<Column> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Column>(end);
    return o;
  }
};

inline flatbuffers::Offset<Column> CreateColumn(
    flatbuffers::FlatBufferBuilder &_fbb,
    Type type = Type_Bool8,
    const Buffer *data = nullptr,
    const Buffer *strdata = nullptr,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint64_t nullcount = 0,
    Stats stats_type = Stats_NONE,
    flatbuffers::Offset<void> stats = 0) {
  ColumnBuilder builder_(_fbb);
  builder_.add_nullcount(nullcount);
  builder_.add_stats(stats);
  builder_.add_name(name);
  builder_.add_strdata(strdata);
  builder_.add_data(data);
  builder_.add_stats_type(stats_type);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Column> CreateColumnDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Type type = Type_Bool8,
    const Buffer *data = nullptr,
    const Buffer *strdata = nullptr,
    const char *name = nullptr,
    uint64_t nullcount = 0,
    Stats stats_type = Stats_NONE,
    flatbuffers::Offset<void> stats = 0) {
  return jay::CreateColumn(
      _fbb,
      type,
      data,
      strdata,
      name ? _fbb.CreateString(name) : 0,
      nullcount,
      stats_type,
      stats);
}

inline bool VerifyStats(flatbuffers::Verifier &, const void *, Stats type) {
  switch (type) {
    case Stats_NONE: {
      return true;
    }
    case Stats_Bool: {
      return true;
    }
    case Stats_Int8: {
      return true;
    }
    case Stats_Int16: {
      return true;
    }
    case Stats_Int32: {
      return true;
    }
    case Stats_Int64: {
      return true;
    }
    case Stats_Float32: {
      return true;
    }
    case Stats_Float64: {
      return true;
    }
  }
  return false;
}

inline bool VerifyStatsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyStats(
        verifier,  values->Get(i), types->GetEnum<Stats>(i))) {
      return false;
    }
  }
  return true;
}

inline const jay::Frame *GetFrame(const void *buf) {
  return flatbuffers::GetRoot<jay::Frame>(buf);
}

inline const jay::Frame *GetSizePrefixedFrame(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<jay::Frame>(buf);
}

inline bool VerifyFrameBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<jay::Frame>(nullptr);
}

inline bool VerifySizePrefixedFrameBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<jay::Frame>(nullptr);
}

inline void FinishFrameBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<jay::Frame> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedFrameBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<jay::Frame> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace jay

#endif  // FLATBUFFERS_GENERATED_JAY_JAY_H_
