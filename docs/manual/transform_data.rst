
Transforming Data
=================

Example Data
------------

    >>> from datatable import dt, f, update, ifelse
    >>> from datetime import date
    >>>
    >>> source = {"dates" : [date(2000, 1, 5), date(2010, 11, 23), date(2020, 2, 29), None],
    ...           "integers" : range(1, 5),
    ...           "floats" : [10.0, 11.5, 12.3, -13],
    ...           "strings" : ['A', 'B', None, 'D']
    ...           }
    >>> DT = dt.Frame(source)
    >>> DT
       | dates       integers   floats  strings
       | date32         int32  float64  str32
    -- + ----------  --------  -------  -------
     0 | 2000-01-05         1     10    A
     1 | 2010-11-23         2     11.5  B
     2 | 2020-02-29         3     12.3  NA
     3 | NA                 4    -13    D
    [4 rows x 4 columns]


Column Transformation
---------------------
Operations on columns occur in the  `j` section of ``DT[i, j, by/sort/...]``, and involve the use of :ref:`f-expressions`::

   >>> DT[:, f.integers * 2]
      |    C0
      | int32
   -- + -----
    0 |     2
    1 |     4
    2 |     6
    3 |     8
   [4 rows x 1 column]


   >>> DT[:, 'pre_' + f.strings]
      | C0
      | str32
   -- + -----
    0 | pre_A
    1 | pre_B
    2 | NA
    3 | pre_D
   [4 rows x 1 column]

Operation between columns is possible::

   >>> DT[:, f.integers + f.floats]
      |      C0
      | float64
   -- + -------
    0 |    11
    1 |    13.5
    2 |    15.3
    3 |    -9
   [4 rows x 1 column]

   >>> DT[:, f.integers +'_' + f.strings]
      | C0
      | str32
   -- + -----
    0 | 1_A
    1 | 2_B
    2 | NA
    3 | 4_D
   [4 rows x 1 column]

.. note::

    Operations between columns creates new columns; the column name is autogenerated, unless otherwise specified.

Various Datatable Functions can be applied to the columns::

   >>> DT[:, dt.math.pow(f.floats, 3)]
      |       C0
      |  float64
   -- + --------
    0 |  1000
    1 |  1520.88
    2 |  1860.87
    3 | -2197
   [4 rows x 1 column]

   >>> DT[:, dt.time.year(f.dates)]
      | dates
      | int32
   -- + -----
    0 |  2000
    1 |  2010
    2 |  2020
    3 |    NA
   [4 rows x 1 column]

There are some Datatable functions that only operate column-wise::

   >>> DT[:, f['integers':'floats'].sum()]
      | integers   floats
      |    int64  float64
   -- + --------  -------
    0 |       10     20.8
   [1 row x 2 columns]

while some other Datatable functions operate row-wise::

   >>> DT[:, f['integers':'floats'].rowsum()]
      |      C0
      | float64
   -- + -------
    0 |    11
    1 |    13.5
    2 |    15.3
    3 |    -9
   [4 rows x 1 column]

Transformation of a column based on a condition is possible via :func:`ifelse()`, which operates similarly to Python's `if-else` idiom::

   >>> DT[:, ifelse(f.integers % 2 == 0, 'even', 'odd')]
      | C0
      | str32
   -- + -----
    0 | odd
    1 | even
    2 | odd
    3 | even
   [4 rows x 1 column]

Iteration on a Frame
--------------------
Iterating through a :class:`Frame` allows access to the individual columns; in this case, each column is treated as a frame::

   >>> [frame for frame in DT]

      | dates
      | date32
   -- + ----------
    0 | 2000-01-05
    1 | 2010-11-23
    2 | 2020-02-29
    3 | NA
   [4 rows x 1 column]

      | integers
      |    int32
   -- + --------
    0 |        1
    1 |        2
    2 |        3
    3 |        4
   [4 rows x 1 column]

      |  floats
      | float64
   -- + -------
    0 |    10
    1 |    11.5
    2 |    12.3
    3 |   -13
   [4 rows x 1 column]

      | strings
      | str32
   -- + -------
    0 | A
    1 | B
    2 | NA
    3 | D
   [4 rows x 1 column]

With iteration, different operations can be applied to different columns::

   >>> outcome = [frame.mean() if frame.type.is_numeric else frame[0, :] for frame in DT]
   >>> outcome
      | dates
      | date32
   -- + ----------
    0 | 2000-01-05
   [1 row x 1 column]

      | integers
      |  float64
   -- + --------
    0 |      2.5
   [1 row x 1 column]

      |  floats
      | float64
   -- + -------
    0 |     5.2
   [1 row x 1 column]

      | strings
      | str32
   -- + -------
    0 | A
   [1 row x 1 column]


   >>> DT[:, outcome] # or dt.cbind(outcome)
      | dates       integers   floats  strings
      | date32       float64  float64  str32
   -- + ----------  --------  -------  -------
    0 | 2000-01-05       2.5      5.2  A
   [1 row x 4 columns]


Sorting a Frame
---------------
A frame can be sorted via the :func:`sort()` function, or the :meth:`datatable.Frame.sort` method::

   >>> DT[:, :, dt.sort('dates')]
      | dates       integers   floats  strings
      | date32         int32  float64  str32
   -- + ----------  --------  -------  -------
    0 | NA                 4    -13    D
    1 | 2000-01-05         1     10    A
    2 | 2010-11-23         2     11.5  B
    3 | 2020-02-29         3     12.3  NA
   [4 rows x 4 columns]

   >>> DT.sort('dates')
      | dates       integers   floats  strings
      | date32         int32  float64  str32
   -- + ----------  --------  -------  -------
    0 | NA                 4    -13    D
    1 | 2000-01-05         1     10    A
    2 | 2010-11-23         2     11.5  B
    3 | 2020-02-29         3     12.3  NA
   [4 rows x 4 columns]

Sorting is possible via :ref:`f-expressions`::

   >>>  DT[:, :, dt.sort(f.floats)]
      | dates       integers   floats  strings
      | date32         int32  float64  str32
   -- + ----------  --------  -------  -------
    0 | NA                 4    -13    D
    1 | 2000-01-05         1     10    A
    2 | 2010-11-23         2     11.5  B
    3 | 2020-02-29         3     12.3  NA
   [4 rows x 4 columns]

   >>> DT.sort(f.strings)
      | dates       integers   floats  strings
      | date32         int32  float64  str32
   -- + ----------  --------  -------  -------
    0 | 2020-02-29         3     12.3  NA
    1 | 2000-01-05         1     10    A
    2 | 2010-11-23         2     11.5  B
    3 | NA                 4    -13    D
   [4 rows x 4 columns]

The default sorting order is ascending; if there are any nulls in the sorting columns, they go to the top.

The sorting order and the position of nulls can be changed in a number of ways:

-  Sorting can be in descending order via the `reverse` parameter::

      >>> DT[:, :, dt.sort('integers', reverse = True)]
         | dates       integers   floats  strings
         | date32         int32  float64  str32
      -- + ----------  --------  -------  -------
       0 | NA                 4    -13    D
       1 | 2020-02-29         3     12.3  NA
       2 | 2010-11-23         2     11.5  B
       3 | 2000-01-05         1     10    A
      [4 rows x 4 columns]

.. note::

   The ``reverse`` parameter is available only in the :func:`sort()` function

- Sorting in descending order is possible by negating the :ref:`f-expressions` within the :func:`sort()` function, or the :meth:`datatable.Frame.sort` method::

      >>> DT[:, :, dt.sort(-f.integers)]
         | dates       integers   floats  strings
         | date32         int32  float64  str32
      -- + ----------  --------  -------  -------
       0 | NA                 4    -13    D
       1 | 2020-02-29         3     12.3  NA
       2 | 2010-11-23         2     11.5  B
       3 | 2000-01-05         1     10    A
      [4 rows x 4 columns]


      >>> DT.sort(-f.integers)
         | dates       integers   floats  strings
         | date32         int32  float64  str32
      -- + ----------  --------  -------  -------
       0 | NA                 4    -13    D
       1 | 2020-02-29         3     12.3  NA
       2 | 2010-11-23         2     11.5  B
       3 | 2000-01-05         1     10    A
      [4 rows x 4 columns]

- The position of null values within the sorting column can be controlled with the ``na_position`` parameter::

      >>> DT[:, :, dt.sort('dates', na_position = 'last')]
         | dates       integers   floats  strings
         | date32         int32  float64  str32
      -- + ----------  --------  -------  -------
       0 | 2000-01-05         1     10    A
       1 | 2010-11-23         2     11.5  B
       2 | 2020-02-29         3     12.3  NA
       3 | NA                 4    -13    D
      [4 rows x 4 columns]

- Rows with null values can be removed as well by passing `remove` to the ``na_position`` parameter::

   >>> # only the row where date is null is removed
   >>> DT[:, :, dt.sort('dates', na_position='remove')]
      | dates       integers   floats  strings
      | date32         int32  float64  str32
   -- + ----------  --------  -------  -------
    0 | 2000-01-05         1     10    A
    1 | 2010-11-23         2     11.5  B
    2 | 2020-02-29         3     12.3  NA
   [3 rows x 4 columns]

.. note::

   The `na_position` parameter is available only in the :func:`sort()` function.

.. note::

   The default value for ``na_position`` is `first`

Sorting is possible on multiple columns::

   >>> DT[:, :, dt.sort('dates', 'integers')]
      | dates       integers   floats  strings
      | date32         int32  float64  str32
   -- + ----------  --------  -------  -------
    0 | NA                 4    -13    D
    1 | 2000-01-05         1     10    A
    2 | 2010-11-23         2     11.5  B
    3 | 2020-02-29         3     12.3  NA
   [4 rows x 4 columns]

   >>> DT.sort('dates', 'integers')
      | dates       integers   floats  strings
      | date32         int32  float64  str32
   -- + ----------  --------  -------  -------
    0 | NA                 4    -13    D
    1 | 2000-01-05         1     10    A
    2 | 2010-11-23         2     11.5  B
    3 | 2020-02-29         3     12.3  NA
   [4 rows x 4 columns]


Column Assignment
-----------------
Transformed columns can be assigned to new columns, or replace existing columns via direct assignment and the :func:`update()` function. A third option, `extend`, applies only when creating new columns.

Direct Assignment
^^^^^^^^^^^^^^^^^

- Single column::

   >>> DT['months'] = DT[:, dt.time.month(f.dates)]
   >>> DT
      | dates       integers   floats  strings  months
      | date32         int32  float64  str32     int32
   -- + ----------  --------  -------  -------  ------
    0 | 2000-01-05         1     10    A             1
    1 | 2010-11-23         2     11.5  B            11
    2 | 2020-02-29         3     12.3  NA            2
    3 | NA                 4    -13    D            NA
   [4 rows x 5 columns]

- Multiple columns::

   >>> DT[:, ['months', 'int_squared']] = DT[:, [dt.time.month(f.dates),
   ...                                           f.integers**2]]
   >>> DT
      | dates       integers   floats  strings  months  int_squared
      | date32         int32  float64  str32     int32      float64
   -- + ----------  --------  -------  -------  ------  -----------
    0 | 2000-01-05         1     10    A             1            1
    1 | 2010-11-23         2     11.5  B            11            4
    2 | 2020-02-29         3     12.3  NA            2            9
    3 | NA                 4    -13    D            NA           16
   [4 rows x 6 columns]

- Update existing column::

   >>> DT['strings'] = DT[:, f.strings + "_end"]
   >>> DT
      | dates       integers   floats  strings  months  int_squared
      | date32         int32  float64  str32     int32      float64
   -- + ----------  --------  -------  -------  ------  -----------
    0 | 2000-01-05         1     10    A_end         1            1
    1 | 2010-11-23         2     11.5  B_end        11            4
    2 | 2020-02-29         3     12.3  NA            2            9
    3 | NA                 4    -13    D_end        NA           16
   [4 rows x 6 columns]


:func:`update()`
^^^^^^^^^^^^^^^^

:func:`update()` is an in-place operation, and as such, a direct assignment is not required.

:func:`update()` uses keyword arguments, where the key in the dictionary is the name of the new column, while the value is the :ref:`f-expressions` to be computed.


- Single column::

   >>> DT[:, update(year = dt.time.year(f.dates))]
   >>> DT
      | dates       integers   floats  strings  months  int_squared   year
      | date32         int32  float64  str32     int32      float64  int32
   -- + ----------  --------  -------  -------  ------  -----------  -----
    0 | 2000-01-05         1     10    A_end         1            1   2000
    1 | 2010-11-23         2     11.5  B_end        11            4   2010
    2 | 2020-02-29         3     12.3  NA            2            9   2020
    3 | NA                 4    -13    D_end        NA           16     NA
   [4 rows x 7 columns]

- Multiple columns::

   >>> DT[:, update(year = dt.time.year(f.dates),
   ...              float_doubled = f.floats * 2)]
   >>> DT
      | dates       integers   floats  strings  months  int_squared   year  float_doubled
      | date32         int32  float64  str32     int32      float64  int32        float64
   -- + ----------  --------  -------  -------  ------  -----------  -----  -------------
    0 | 2000-01-05         1     10    A_end         1            1   2000           20
    1 | 2010-11-23         2     11.5  B_end        11            4   2010           23
    2 | 2020-02-29         3     12.3  NA            2            9   2020           24.6
    3 | NA                 4    -13    D_end        NA           16     NA          -26
   [4 rows x 8 columns]

- Update existing column::

   >>> DT[:, update(strings = f.strings[:1])]
   >>> DT
      | dates       integers   floats  strings  months  int_squared   year  float_doubled
      | date32         int32  float64  str32     int32      float64  int32        float64
   -- + ----------  --------  -------  -------  ------  -----------  -----  -------------
    0 | 2000-01-05         1     10    A             1            1   2000           20
    1 | 2010-11-23         2     11.5  B            11            4   2010           23
    2 | 2020-02-29         3     12.3  NA            2            9   2020           24.6
    3 | NA                 4    -13    D            NA           16     NA          -26
   [4 rows x 8 columns]



Extend
^^^^^^

The `extend` method works via :ref:`f-expressions` to create new columns; it does not update existing columns.

The `extend` method uses a dictionary to create the new columns, where the key in the dictionary is the name of the new column, while the value is the :ref:`f-expressions` to be computed.

First, let's restore DT to the original frame::

   >>> DT = DT[:, :4]
   >>> DT
      | dates       integers   floats  strings
      | date32         int32  float64  str32
   -- + ----------  --------  -------  -------
    0 | 2000-01-05         1     10    A
    1 | 2010-11-23         2     11.5  B
    2 | 2020-02-29         3     12.3  NA
    3 | NA                 4    -13    D
   [4 rows x 4 columns]

- Single column::

   >>> DT = DT[:, f[:].extend({"months" : dt.time.month(f.dates)})]
   >>> DT
      | dates       integers   floats  strings  months
      | date32         int32  float64  str32     int32
   -- + ----------  --------  -------  -------  ------
    0 | 2000-01-05         1     10    A             1
    1 | 2010-11-23         2     11.5  B            11
    2 | 2020-02-29         3     12.3  NA            2
    3 | NA                 4    -13    D            NA
   [4 rows x 5 columns]

- Multiple columns::

   >>> DT = DT[:, f[:].extend({"year" : dt.time.year(f.dates),
   ...                         "int_squared" : f.integers ** 2})]
   >>> DT
      | dates       integers   floats  strings  months   year  int_squared
      | date32         int32  float64  str32     int32  int32      float64
   -- + ----------  --------  -------  -------  ------  -----  -----------
    0 | 2000-01-05         1     10    A             1   2000            1
    1 | 2010-11-23         2     11.5  B            11   2010            4
    2 | 2020-02-29         3     12.3  NA            2   2020            9
    3 | NA                 4    -13    D            NA     NA           16
   [4 rows x 7 columns]


.. note::

   In contrast to :func:`update()`, the result has to be assigned to `DT`.