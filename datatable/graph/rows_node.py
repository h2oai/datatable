#!/usr/bin/env python3
# Copyright 2017 H2O.ai; Apache License Version 2.0;  -*- encoding: utf-8 -*-
import types

import datatable
import datatable.lib._datatable as _datatable
from .iterator_node import IteratorNode
from datatable.expr import BaseExpr
from datatable.graph.dtproxy import f
from datatable.types import stype, ltype
from datatable.utils.misc import normalize_slice, normalize_range
from datatable.utils.misc import plural_form as plural
from datatable.utils.typechecks import (
    is_type, TValueError, TTypeError, DataTable_t, NumpyArray_t
)
from typing import Optional


#===============================================================================

class RFNode(object):
    """
    Internal abstract class, base for all "row filter" nodes.

    A row filter node represents a `rows` argument in the generic datatable
    call, and its primary function is to compute and return an
    :class:`_datatable.RowIndex` object. It also provides an interface for
    accessing the RowIndex from a C module if needed.

    A row filter is always applied to some DataTable, called "target". Sometimes
    the target is a view, in which case the rowindex must be "uplifted" to the
    parent DataTable. The RowIndex returned by this node will be the "final"
    one, i.e. it will be indexing the actual data columns of the target
    DataTable.

    API:
      - get_final_rowindex(): return the final RowIndex object
      - get_target_rowindex(): return the RowIndex as applied to the target DT
      - var_final_rowindex(): return string expression which can be evaluated
        in the context of a C module to produce the final RowIndex object.

    The primary way of constructing instances of this class is through the
    factory function :func:`make_rowfilter`.

    Parameters
    ----------
    dt: DataTable
        The target DataTable to which the row filter applies.
    ...:
        (Derived classes will typically add their own constructor parameters).
    """
    __slots__ = ("_dt", "_rifinal")

    def __init__(self, dt):
        self._dt = dt
        self._rifinal = None


    def get_final_rowindex(self) -> Optional[_datatable.RowIndex]:
        """
        Return the final RowIndex object.

        If the target DataTable is a view, then the returned RowIndex is an
        uplifted version of the target RowIndex. Otherwise the final RowIndex is
        the same object as the target RowIndex. The returned value may also be
        None indicating absense of any RowIndex.
        """
        if self._rifinal is None:
            _dt = self._dt.internal
            _ri = self.get_target_rowindex()
            if _dt.isview:
                _ri = _datatable.rowindex_uplift(_ri, _dt)
            self._rifinal = _ri
        return self._rifinal


    def get_target_rowindex(self) -> Optional[_datatable.RowIndex]:
        """
        Return the target RowIndex object.

        This method must be implemented in all subclasses. It should return a
        RowIndex object as applied to the target DataTable, or None if no index
        is necessary.
        """
        raise NotImplementedError


    def var_final_rowindex(self) -> str:
        """
        Return string expression that evaluates to the final RowIndex in C.

        The purpose of this function is to facilitate C module construction at
        runtime. The returned string will be used as follows:

            "RowIndex *ri = %s;" % rfnode.var_final_rowindex()

        and this should produce a valid C code.

        The default implementation first creates the final rowindex, and then
        passes it as a numeric pointer. Children classes may override this
        method to provide a different approach.
        """
        ri = self.get_final_rowindex()
        # TODO: ensure that the pointer survives
        return "((void*) %d)" % (ri.getptr() if ri else 0)



#===============================================================================

class AllRFNode(RFNode):
    """
    RFNode representing selection of all rows from the datatable.

    Although "all rows" selector can easily be implemented as a slice, we want
    to have a separate class because (1) this is a very common selector type,
    and (2) in some cases useful optimizations can be achieved if we know that
    all rows are selected from a datatable.
    """
    __slots__ = ()

    def get_target_rowindex(self):
        return None



#===============================================================================

class SliceRFNode(RFNode):
    """
    RFNode representing a slice subset of target's rows.

    Parameters
    ----------
    dt: DataTable
        The target DataTable.

    start, count, step: int
        The parameters of the slice. The slice represents a list of integers
        `[start + i*step for i in range(count)]`. Here `step` can be positive,
        negative, or even zero; however all indices generated by the slice must
        be in the range `[0; dt.nrows)`.
    """
    __slots__ = ("_triple", )

    def __init__(self, dt, start: int, count: int, step: int):
        super().__init__(dt)
        assert start >= 0 and count >= 0 and start + (count - 1) * step >= 0
        self._triple = (start, count, step)

    def get_target_rowindex(self):
        return _datatable.rowindex_from_slice(*self._triple)



#===============================================================================

class ArrayRFNode(RFNode):
    """
    RFNode selecting rows from the target via an explicit list of indices.

    Parameters
    ----------
    dt: DataTable
        The target DataTable.

    array: List[int]
        The list of row indices that should be selected from the target
        DataTable. The indices must be in the `range(dt.nrows)` (however this
        constraint is not verified here).
    """
    __slots__ = ("_array", )

    def __init__(self, dt, array):
        super().__init__(dt)
        self._array = array

    def get_target_rowindex(self):
        return _datatable.rowindex_from_array(self._array)



#===============================================================================

class MultiSliceRFNode(RFNode):
    """
    RFNode representing selection of rows via a list of slices.

    This class is a generalized version of :class:`SliceRFNode` and
    :class:`ArrayRFNode`.

    Parameters
    ----------
    dt: DataTable
        The target DataTable.

    bases, counts, steps: List[int]
        Three lists describing the row slices to be selected. In particular,
        each triple `(bases[i], counts[i], steps[i])` describes one slice. Lists
        `counts` and `steps` must have equal lengths, but may be shorter than
        `bases` (in which case it is assumed that missing elements in `counts`
        and `steps` are equal to 1).
    """
    __slots__ = ("_bases", "_counts", "_steps")

    def __init__(self, dt, bases, counts, steps):
        super().__init__(dt)
        self._bases = bases
        self._counts = counts
        self._steps = steps

    def get_target_rowindex(self):
        return _datatable.rowindex_from_slicelist(
            self._bases, self._counts, self._steps
        )



#===============================================================================

class BooleanColumnRFNode(RFNode):
    """
    RFNode that selects rows according to the provided boolean mask.

    Parameters
    ----------
    dt: DataTable
        The target DataTable.

    col: DataTable
        The "mask" DataTable containing a single boolean column of the same
        length as the target DataTable. Only rows corresponding to the `True`
        values in the mask will be selected.
    """
    __slots__ = ("_coldt", )

    def __init__(self, dt, col):
        super().__init__(dt)
        assert col.shape == (dt.nrows, 1)
        self._coldt = col

    def get_target_rowindex(self):
        return _datatable.rowindex_from_boolcolumn(self._coldt.internal)



#===============================================================================

class IntegerColumnRFNode(RFNode):
    """
    RFNode that treats the provided integer column as a RowIndex.

    Parameters
    ----------
    dt: DataTable
        The target DataTable.

    col: DataTable
        DataTable containing a single integer column, the values in this column
        will be treated as row indices to select.
    """
    __slots__ = ("_coldt", )

    def __init__(self, dt, col):
        super().__init__(dt)
        self._coldt = col

    def get_target_rowindex(self):
        return _datatable.rowindex_from_intcolumn(self._coldt.internal,
                                                  self._dt.nrows)



#===============================================================================

class FilterExprRFNode(RFNode):
    """
    RFNode that creates a RowIndex out of the provided expression.

    This node will select those rows for which the provided expression returns
    True when evaluated. Thus, it is equivalent to first evaluating the provided
    expression as a boolean column, and then passing it to a
    :class:`BooleanColumnRFNode`.

    This class overrides :meth:`var_final_rowindex` so that it behaves lazily:
    calling this method will not cause the underlying CModule to be compiled,
    whereas calling :meth:`get_final_rowindex` will.

    Parameters
    ----------
    dt: DataTable
        The target DataTable.

    expr: BaseExpr
        Expression (yielding a boolean column) that will be evaluated in order
        to construct the RowIndex.

    cmod: CModule
        The context for evaluating the expression.
    """
    __slots__ = ["_cmodule", "_fnname", "_expr"]

    def __init__(self, dt, expr, cmod):
        super().__init__(dt)
        expr.resolve()
        assert expr.stype == stype.bool8
        self._cmodule = cmod
        self._expr = expr
        self._fnname = cmod.make_variable_name("make_rowindex")
        cmod.add_node(self)

    def get_final_rowindex(self):
        ptr = self._cmodule.get_result(self._fnname)
        return _datatable.rowindex_from_function(ptr)

    def var_final_rowindex(self):
        return self._fnname + "()"

    def generate_c(self) -> None:
        """
        This method will be invoked by CModule during code generation.
        """
        cmod = self._cmodule
        inode = IteratorNode(self._dt, cmod, name="filter")
        v = self._expr.value_or_0(inode=inode)
        inode.addto_preamble("int64_t j = 0;")
        inode.addto_mainloop("if (%s) {" % v)
        inode.addto_mainloop("    out[j++] = i;")
        inode.addto_mainloop("}")
        inode.addto_epilogue("*n_outs = j;")
        inode.set_extra_args("int32_t *out, int32_t *n_outs")
        inode.generate_c()

        rowindex_name = cmod.make_variable_name("rowindex")
        cmod.add_global(rowindex_name, "void*", "NULL")
        cmod.add_function(
            self._fnname,
            "void* {fnname}(void) {{\n"
            "    if (!{riname})\n"
            "        {riname} = rowindex_from_filterfn32(\n"
            "                       (void*) {filter}, {nrows}, {sorted});\n"
            "    return {riname};\n"
            "}}".format(fnname=self._fnname,
                        riname=rowindex_name,
                        filter=inode.fnname,
                        sorted=int(not self._dt.internal.isview),
                        nrows=self._dt.nrows))



#===============================================================================

class SortedRFNode(RFNode):

    def __init__(self, sort_node):
        super().__init__(sort_node._dt)
        self._sortnode = sort_node

    def get_final_rowindex(self):
        return self._sortnode.make_rowindex()



#===============================================================================
# Factory function
#===============================================================================

def make_rowfilter(rows, dt, cmod, _nested=False):
    """
    Create an :class:`RFNode` from the provided expression.

    This is a factory function that instantiates an appropriate subclass of
    :class:`RFNode`, depending on the provided argument `rows`, assuming it is
    applied to the datatable `dt`.

    Parameters
    ----------
    rows:
        An expression that will be converted into one of the RFNodes. This can
        have a variety of different types, see `help(DataTable.__call__)` for
        more information.

    dt: DataTable
        The target DataTable.

    cmod: CModule
        The evaluation context within which the expression should be computed.
        Applicable only when `rows` is a `BaseExpr` object.

    _nested: bool, default False
        Internal attribute, used to avoid deep recursion when `make_rowfilter()`
        calls itself. When this attribute is False recursion is allowed,
        otherwise not.
    """
    nrows = dt.nrows
    if rows is Ellipsis or rows is None:
        return AllRFNode(dt)

    if rows is True or rows is False:
        # Note: True/False are integer objects in Python
        raise TTypeError("Boolean value cannot be used as a `rows` selector")

    # from_scalar = False
    if isinstance(rows, (int, slice, range)):
        # from_scalar = True
        rows = [rows]

    from_generator = False
    if isinstance(rows, types.GeneratorType):
        # If an iterator is given, materialize it first. Otherwise there
        # is no way to ensure that the produced indices are valid.
        rows = list(rows)
        from_generator = True

    if isinstance(rows, (list, tuple, set)):
        bases = []
        counts = []
        steps = []
        for i, elem in enumerate(rows):
            if isinstance(elem, int):
                if -nrows <= elem < nrows:
                    # `elem % nrows` forces the row number to become positive
                    bases.append(elem % nrows)
                else:
                    raise TValueError(
                        "Row `%d` is invalid for datatable with %s"
                        % (elem, plural(nrows, "row")))
            elif isinstance(elem, (range, slice)):
                if elem.step == 0:
                    raise TValueError("In %r step must not be 0" % elem)
                if not all(x is None or isinstance(x, int)
                           for x in (elem.start, elem.stop, elem.step)):
                    raise TValueError("%r is not integer-valued" % elem)
                if isinstance(elem, range):
                    res = normalize_range(elem, nrows)
                    if res is None:
                        raise TValueError(
                            "Invalid %r for a datatable with %s"
                            % (elem, plural(nrows, "row")))
                else:
                    res = normalize_slice(elem, nrows)
                start, count, step = res
                assert count >= 0
                if count == 0:
                    pass  # don't do anything
                elif count == 1:
                    bases.append(start)
                else:
                    if len(counts) < len(bases):
                        counts += [1] * (len(bases) - len(counts))
                        steps += [1] * (len(bases) - len(steps))
                    bases.append(start)
                    counts.append(count)
                    steps.append(step)
            else:
                if from_generator:
                    raise TValueError(
                        "Invalid row selector %r generated at position %d"
                        % (elem, i))
                else:
                    raise TValueError(
                        "Invalid row selector %r at element %d of the "
                        "`rows` list" % (elem, i))
        if not counts:
            if len(bases) == 1:
                return SliceRFNode(dt, bases[0], 1, 1)
            else:
                return ArrayRFNode(dt, bases)
        elif len(bases) == 1:
            if bases[0] == 0 and counts[0] == nrows and steps[0] == 1:
                return AllRFNode(dt)
            else:
                return SliceRFNode(dt, bases[0], counts[0], steps[0])
        else:
            return MultiSliceRFNode(dt, bases, counts, steps)

    if is_type(rows, NumpyArray_t):
        arr = rows
        if not (len(arr.shape) == 1 or
                len(arr.shape) == 2 and min(arr.shape) == 1):
            raise TValueError("Only a single-dimensional numpy.array is allowed"
                              " as a `rows` argument, got %r" % arr)
        if len(arr.shape) == 2 and arr.shape[1] > 1:
            arr = arr.T
        if not (str(arr.dtype) == "bool" or str(arr.dtype).startswith("int")):
            raise TValueError("Either a boolean or an integer numpy.array is "
                              "expected for `rows` argument, got %r" % arr)
        if str(arr.dtype) == "bool" and arr.shape[-1] != dt.nrows:
            raise TValueError("Cannot apply a boolean numpy array of length "
                              "%d to a datatable with %s"
                              % (arr.shape[-1], plural(dt.nrows, "row")))
        rows = datatable.DataTable(arr)
        assert rows.ncols == 1
        assert rows.ltypes[0] == ltype.bool or rows.ltypes[0] == ltype.int

    if is_type(rows, DataTable_t):
        if rows.ncols != 1:
            raise TValueError("`rows` argument should be a single-column "
                              "datatable, got %r" % rows)
        col0type = rows.ltypes[0]
        if col0type == ltype.bool:
            if rows.nrows != dt.nrows:
                s1rows = plural(rows.nrows, "row")
                s2rows = plural(dt.nrows, "row")
                raise TValueError("`rows` datatable has %s, but applied to a "
                                  "datatable with %s" % (s1rows, s2rows))
            return BooleanColumnRFNode(dt, rows)
        elif col0type == ltype.int:
            return IntegerColumnRFNode(dt, rows)
        else:
            raise TTypeError("`rows` datatable should be either a boolean or "
                             "an integer column, however it has type %s"
                             % col0type)

    if isinstance(rows, types.FunctionType):
        return make_rowfilter(rows(f), dt, cmod, _nested=True)

    if isinstance(rows, BaseExpr):
        return FilterExprRFNode(dt, rows, cmod)

    if _nested:
        raise TTypeError("Unexpected result produced by the `rows` "
                         "function: %r" % rows)
    else:
        raise TTypeError("Unexpected `rows` argument: %r" % rows)
